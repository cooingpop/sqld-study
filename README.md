# sqld-study



## 데이터 모델링의 이해

##### 발생시점에 따른 엔터티 분류

- 기본/키엔터티(Fundamental Entity, Key Entity)

- 중심엔터티(Main Entity)

- 행위엔터티(Active Entity)

##### 모델링의 특징

현실세계를 일정한 형식에 맞추어 표현하는 추상화의 의미를 가질 수 있음.

복잡한 현실을 제한된 언어나 표기법을 통해 이해하기 쉽게 하는 단순화의 의미를 가지고 있음

애매모호함을 배제하고 누구나 이해가 가능하도록 정확하게 현상을 기술하는 정확화의 의미를 가짐


##### 데이터 모델링이란

정보시스템을 구축하기 위한 데이터 관점의 업무 분석 기법

현실세계의 데이터(what)에 대해 약속된 표기법에 의해 표현하는 과정

데이터베이스를 구축하기 위한 분석/설계의 과정


##### 데이터 모델링이 필요한 주요 이유

업무정보를 구성하는 기초가 되는 정보들에 대해 일정한 표기법에 의해 표현한다

분석된 모델을 가지고 데이터베이스를 생성하여 개발 및 데이터 관리에 사용하기 위한 것이다.

데이터모델링 자체로서 업무의 흐름을 설명하고 분석하는 부분에 의미를 가지고 있다.


##### 데이터모델링의 유의점

데이터 모델을 어떻게 설계했느냐에 따라 사소한 업무변화에도 데이터 모델이 수시로 변경됨으로써 유지보수의 어려움을 가중시킬 수 있다. (비유연성)

데이터의 정의를 데이터의 사용 프로세스와 분리함으로써 데이터 모델링은 데이터 혹은 프로세스의 작은 변화가 애플리케이션과 데이터베이스에 중대한 변화를 일으킬 수 있는 가능성을 줄인다.(비유연성)

여러 장소의 데이터베이스에 같은 정보를 저장하지 않도록 하여 중복성을 최소화 한다.(중복)

데이터의 정의를 데이터의 사용 프로세스와 분리하여 유연성을 높인다.(비유연성)

데이터간의 상호 연관관계를 명확하게 정의하여 일관성 있게 데이터가 유지되도록 한다.(비일관성)

- 중복
- 비유연성
- 비일관성

##### 개념적 데이터 모델링

- 추상화 수준이 높고 업무중심적으로 포괄적인 수준의 모델링 진행.
- 전사적 데이터 모델링
- EA수립시 많이 이용

##### 논리적 데이터 모델링

- 시스템을 구축하고자 하는 업무에 대해 Key,  속성, 관계 등을 정확하게 표현, 재사용성이 높음

##### 물리적 데이터 모델링

- 실제로 데이터베이스에 이식할 수 있도록 성능, 저장 등 물리적인 성격을 고려하여 설계

##### 데이터 모델
전사적 데이터 모델링을 수행할 때 많이 하며, 추상화 수준이 높고 업무 중심적으로 포괄적인 수준의 모델링을 진행하는 것을 ***개념적*** 데이터 모델링 이라고 한다.

이와 달리 실제로 데이터베이스에 이식할 수 있도록 성능, 저장 등의 물리적인 성격을 고려한 데이터 모델링은 ***물리적*** 데이터 모델링 이라고 한다.

##### 데이터베이스 스키마 구조 3단계

- 외부스키마(External Schema)
- 개념스키마(Conceptual Schema)
  - 모든 사용자 관점을 통합한 조직 전체 관점의 통합적 표현
  - 모든 응용시트템들이나 사용자들이 필요로 하는 데이터를 통합한 조직 전체의 DB를 기술한 것으로
    DB에 저장되는 데이터와 그들간의 관계를 표현한 스키마

- 내부스키마(Internal Schema)

##### ERD 작성 순서

1. 엔터티를 그린다.
2. 엔터티를 적절하게 배치한다.
3. 엔터티간 관계를 설정한다.
4. 관계명을 기술한다.
5. 관계의 참여도를 기술한다.
6. 관계의 필수여부를 기술한다.

##### ERD에 대한 설명

1. 1976년 피터첸(Peter Chen)에 의해 Entity-Relationship Model(E-R Model)이라는 표기법이 만들어졌다.

2. 일반적으로 ERD를 작성하는 방법은 엔터티 도출 → 엔터티 배치 → 관계 설정 → 관계명 기술의 흐름으로 작업을 진행한다.
3. 관계의 명칭은 관계 표현에 있어서 매우 중요한 부분에 해당한다.
4. 가장 중요한 엔터티를 왼쪽 상단에 배치하고 추가 발생되는 엔터티들을 오른쪽 편과 하단에 배치하는 것이 원칙이다.

##### 엔터티 

S병원은 여러 명의 환자가 존재하고 각 환자에 대한 이름, 주소 등을 관리해야 한다.

(단, 업무범위와 데이터의 특성은 상기 시나리오에 기술되어 있는 사항만을 근거하여 판단해야 함)

→ 병원은 S병원 1개이므로 엔터티로 성립되지 않는다.

엔터티는 2개 이상의 속성과 2개이상의 인스턴스를 가져 면적으로 표현될 수 있어야 비로소 기본적인 엔터티 자격이 된다.

'여러명'의 복수 인스턴스와 이름, 주소 등의 복수속성을 가진 '환자'가 엔터티로 적절하다.

##### 엔터티의 특징

- 반드시 해당 업무에서 필요하고 관리하고자 하는 정보이어야 한다.(예. 토익의 응시횟수 ...)
- 유일한 식별자에 의해 식별이 가능해야 한다.
- 영속적으로 존재하는 인스턴스의 집합이어야 한다.('한 개'가 아니라 '두 개 이상')
- 업무 프로세스에 의해 이용되어야 한다.
- 반드시 속성이 있어야 한다.
- 다른 엔터티와 최소 한 개 이상의 관계가 있어야 한다.

##### 기본 엔터티

- 기본엔터티(키엔터티)란 그 업무에 원래 존재하는 정보로서 다른 엔터티와의 관계에 의해 생성되지 않고
  독립적으로 생성이 가능하고 자신은 타 엔터티의 부모의 역할을 하게 된다. 다른 엔터티로부터 주식별자를 상속받지않고 자신의 고유한 주식별자를 가지게 된다. 예를 들어 사원, 부서, 고객, 상품, 자재 등이 기본엔터티가 될 수 있다.

##### 엔터티를 부여하는 방법

1. 현업의 업무 용어를 사용하여 업무상의 의미를 분명하게 한다.
2. 모든 엔터티에서 유일한 이름이 부여되어야 한다.
3. 엔터티가 생성되는 의미대로 자연스럽게 부여하도록 한다.
4. 가능하면 약어를 사용하지 않는다.
5. 단수명사를 사용한다.

##### 엔터티, 인스턴스, 속성, 속성값의 관계

- 한 개의 엔터티는 두 개 이상의 인스턴스의 집합이어야 한다.
- 한 개의 엔터티는 두 개 이상의 속성을 갖는다.
- 한 개의 속성은 한 개의 속성값을 갖는다.

##### 속성 

- 사물의 성질, 특징 또는 본질적인 성질.
- "업무에서 필요로 하는 인스턴스에서 관리하고자 하는 의미상 더 이상 분리되지 않는 최소의 데이터 단위"
- 엔터티에 대한 자세하고 구체적인 정보를 나타낸다.
- 하나의 엔터티는 두 개 이상의 속성을 갖는다.
- 속성도 집합이다.
- 하나의 인스턴스에서 각각의 속성은 한 개의 속성값을 가져야 한다.

##### 속성의 특성에 따른 분류

- 기본속성
- 설계속성
- 파생속성
  - 데이터를 조회할 때 빠른 성능을 낼 수 있도록 하기 위해 원래 속성의 값을 계산하여 저장할 수 있도록 만든 속성



##### 데이터 모델의 개념

###### 도메인

- 각 엔터티(테이블)의 속성에 대해서 어떤 유형의 값이 들어가는지를 정의하는 개념
- 엔터티 내에서 속성에 대한 데이터타입과 크기 그리고 제약사항을 지정

##### 속성의 명칭 부여

- 해당 업무에서 사용하는 이름을 부여한다.
- 서술식 속성명은 사용하지 않는다.
- 약어사용은 가급적 제한한다.
- 전체 데이터모델에서 유일성 확보하는 것이 좋다.
- 속성의 명칭은 애매모호하지 않게, 복합 명사를 사용하여 구체적으로 명명함으로써 전체 데이터모델에서 유일성을 확보하는 것이 반정규화, 통합 등의 작업을 할 때 혼란을 방지할 수 있는 방법이 된다.

##### 데이터모델링의 관계

- 관계는 존재에 의한 관계와 행위에 의한 관계로 구분될 수 있으나 ERD에서는 관계를 연결할 때, 존재와 행위를 구분하지 않고 단일화된 표기법을 사용한다.
- UML(Unified Modeling Language)에는 클래스 다이어그램의 관계 중 연관관계(Association)와 의존관계(Dependency)가 있고 이것은 실선과 점선의 표기법으로 다르게 표현이 된다.
- 데이터모델링에서는 존재적 관계와 행위에 의한 관계를 구분하는 표기법이 없으며, UML 에서는 연관관계와 의존관계에 대해 다른 표기법을 가지고 표현하게 되어 있다.

##### 관계

- 관계는 존재적 관계와 행위에 의한 관계로 나누어볼 수 있다.
- 관계의 표기법은 관계명, 관계차수, 선택성(선택사양)의 3가지 개념으로 표현한다.
- 부서와 사원 엔터티 간의 '소속 ' 관계는 존재적 관계의 사례이다.
- 주문과 배송 엔터티 간의 '배송근거' 관계는 행위에 의한 관계의 사례이다.

##### 관계의 표기법

- 관계명(Membership) : 관계의 이름
- 관계차수(Cardinality) : 1:1, 1:M, M;N (관계의 기수성)
- 관계선택사양(Optionality) : 필수관계, 선택관계

##### 두 개의 엔터티 사이에서 관계를 도출 할 때 체크 할 사항

- 두 개의 엔터티 사이에 관심 있는 연관규칙이 존재하는가
- 두 개의 엔터티 사이에 정보의 조합이 발생되는가
- 업무기술서, 장표에 관계연결을 가능하게 하는 동사(Verb)가 있는가
- 업무기술서, 장표에 관계연결에 대한 규칙이 서술되어 있는가

##### 식별자의 종류

- 엔터티 내에서 대표성을 가지는가에 따라 주식별자(Primary Identifier)와 보조식별자(Alternate Identifier)로 구분
- 엔터티 내에서 스스로 생성되었는지 여부에 따라 내부식별자와 외부식별자(Foreign Identifier)로 구분
- 단일 속성으로 식별이 되는가에 따라 단일식별자(Single Identifier)와 복합식별자(Composit Identifier)로 구분
- 원래 업무적으로 의미가 있던 식별자 속성을 대체하여 일련번호와 같이 새롭게 만든 식별자를 구분하기 위해 본질식별자와 인조식별자로 구분

##### 주식별자를 지정할 때 고려해야 할 사항

- 주식별자에 의해 엔터티내에 모든 인스턴스들이 유일하게 구분되어야 한다.
- 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 한다.
- 지정된 주식별자의 값은 자주 변하지 않는 것이어야 한다.
- 주식별자가 지정이 되면 반드시 값이 들어와야 한다.

##### 주식별자의 특징

- 유일성 : 주식별자에 의해 엔터티내에 모든 인스턴스들을 유일하게 구분함
- 최소성 : 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 함
- 불변성 : 주식별자가 한 번 특정 엔터티에 지정되면 그 식별자의 값은 변하지 않아야 함
- 존재성 : 주식별자가 지정되면 반드시 데이터 값이 존재(Null 안됨)


##### 식별자와 비식별자관계 비교

| <center>**항목**</center>           | <center>**식별자 관계**</center> | <center>**비식별자관계**</center> |
| :----------------- | :-------------- | :--------------- |
| <center>목적</center>               | 강한 연결관계 표현 | 약한 연결관계 표현 |
| <center>자식 주식별자 영향</center> | 자식 주 식별자의 구성에 포함됨 | 자식 일반 속성에 포함됨 |
| <center>표기법</center>             | 실선 표현 | 점섬 표현 |
| <center>연결 고려사항</center>      | - 반드시 부모엔터티 종속<br />- 자식 주식별자구성에 부모 주식별자포함 필요<br />- 상속받은 주식별자속성을 타엔터티에 이전 필요 | - 약한 종속관계<br />- 자식 주식별자구성을 독립적으로 구성<br />- 자식 주식별자 구성에 부모 주식별자 부분 필요<br />- 상속받은 주식별자속성을 타 엔터티에 차단 필요<br />- 부모쪽의 관계참여가 선택관계 |



##### 비식별자 관계로 연결하는 것을 고려해야 하는 경우

- 부모엔터티에 참조값이 없어도 자식엔터티의 인스턴스가 생성될 수 있는 경우
- 여러 개의 엔터티를 하나로 통합하면서 각각의 엔터티가 갖고 있던 여러 개의 개별 관계가 통합되는 경우
- 자식쪽 엔터티의 주식별자를 부모엔터테와는 별도로 생성하는 것이 더 유리하다고 판단하는 경우
- 부모엔터티의 인스턴스가 자식의 엔터티와 관계를 가지고 있었지만 자식만 남겨두고 먼저 소멸될 수 있는 경우 비식별자관계로 연결
- 부모엔터티의 인스턴스가 자식 엔터티와 같이 소멸되는 경우는 비식별자 관계보다 식별자 관계로 정의하는 것이 더 적합


##### 식별자의 분류체계

<table>
    <thead>
        <th>분류</th>
        <th>식별자</th>
        <th>설명</th>
    </thead>
    <tr>
        <td width=120 rowspan=2>대표성 여부</td>
        <td width=120>주식별자</td>
        <td>엔터티 내에서 각 어커런스를 구분할 수 있는 구분자이며, 타 엔터티와 참조관계를연결할 수 있는 식별자</td>
    </tr>
	<tr>
    	<td>보조식별자</td>
        <td>엔터티 내에서 각 어커런스를 구분할 수 있는 구분자이나 대표성을 가지지 못해 참조관계를 연결하지 못함</td>
    </tr>
	<tr>
		<td rowspan=2>스스로 <br>생성 여부</td>
        <td>내부식별자</td>
        <td>엔터티 내부에서 스스로 만들어지는 식별자</td>
	</tr>
	<tr>
		<td>외부식별자</td>
        <td>타 엔터티와의 관계를 통해 타 엔터티로부터 받아오는 식별자</td>
	</tr>
    <tr>
		<td rowspan=2>속성의 수</td>
        <td>단일식별자</td>
        <td>하나의 속성으로 구성된 식별자</td>
	</tr>
	<tr>
		<td>복합식별자</td>
        <td>둘 이상의 속성으로 구성된 식별자</td>
	</tr>
    <tr>
		<td rowspan=2>대체 여부</td>
        <td>본질식별자</td>
        <td>업무에 의해 만들어지는 식별자</td>
	</tr>
	<tr>
		<td>인조식별자</td>
        <td>업무적으로 만들어지지는 않지만 원조식별자가 복잡한 구성을 가지고 있기 때문에 인위적으로 만든 식별자</td>
	</tr>
</table>

## 데이터 모델과 성능


##### 성능데이터모델링

- 데이터베이스 성능향상을 목적으로 설계단계의 데이터 모델링 때부터 성능과 관련된 사항이 데이터 모델링에 반영될 수 있도록 하는 것.
- 데이터의 증가가 빠를수록 성능저하에 따른 성능개선비용은 증가한다.
- 데이터모델은 성능을 튜닝하면서 변경이 될 수 있는 특징이 있다.
- 분석/설계 단계에서 성능을 고려한 데이터모델링을 수행할 경우 성능 저하에 따른 Rework비용을 최소화 할 수 있는 기회를 가지게 된다.

###### 문제 발생 시점의 SQL을 중심으로 집중 튜닝하는 것은 성능 데이터모델링과 무관

##### 반정규화(역정규화) 모델링 순서

1. 데이터모델링을 할 때 정규화를 정확하게 수행한다.
2. 데이터베이스 용량산정을 수행한다
3. 데이터베이스에 발생되는 트랜잭션의 유형을 파악한다.
4. 용량과 트랜잭션의 유형에 따라 반정규화를 수행한다.
5. 이력모델의 조정, PK/FK조정, 슈퍼타입/서브타입 조정 등을 수행한다.
6. 성능관점에서 데이터모델을 검증한다.

반정규화 고려할 때 판단 요소

- 다량 데이터 탐색의 경우 인덱스가 아닌 파티션 및 데이터 클러스터링 등의 다양한 물리 저장 기법을 활용하여 성능 개선을 유도할 수 있다. 다만, 하나의 결과셋을 추출하기 위해 다량의 데이터를 탐색하는 처리가 반복적으로 빈번하게 발생한다면 이때는 반정규화를 고려하는 것이 좋다.
- 이전 또는 이후 위치의 레코드에 대한 탐색은 window function으로 접근 가능하다.
- 집계 테이블 이외에도 다양한 유형(다수 테이블의 키 연결 테이블 등)에 대하여 반정규화 테이블 적용이 필요할 수 있다.

##### 테이블의 반정규화

<table>
    <thead>
        <th>기법분류</th>
        <th>반정규화 기법</th>
    </thead>
    <tr>
        <td rowspan=3>테이블 병합</td>
		<td>1:1 관계 테이블 병합</td>
    </tr>
    <tr>
        <td>1:M 관계 테이블병합</td>
    </tr>
    <tr>
        <td>슈퍼/서브타입 테이블병합</td>
    </tr>
    <tr>
        <td rowspan=2>테이블 분할</td>
        <td>수직분할</td>
    </tr>
    <tr>
        <td>수평분할</td>
    </tr>
    <tr>
        <td rowspan=4>테이블추가</td>
        <td>종목테이블 추가</td>
    </tr>
    <tr>
        <td>통계테이블 추가</td>
	</tr>
    <tr>
        <td>이력테이블 추가</td>
	</tr>
    <tr>
        <td>부분테이블 추가</td>
	</tr>
</table>


##### 칼럼의 반정규화

| <center>반정규화 기법</center>     |
| ---------------------------------- |
| 중복칼럼 추가                      |
| 파생칼럼 추가                      |
| 이력테이블 칼럼 추가               |
| PK에 의한 칼럼 추가                |
| 응용시스템 오작동을 위한 칼럼 추가 |

###### 디스크 I/O를 줄이기 위해 해당 칼럼들을 별도로 모아놓는 정규화 기법 : 테이블추가 - 부분테이블 추가



##### 반정규화 절차

1. 반정규화 대상조사
   - 범위처리빈도수 조사
   - 대량의 범위 처리 조사
   - 통계성 프로세스 조사
   - 테이블 조인 갯수
2. 다른 방법유도 검토
   - 뷰(VIEW) 테이블
   - 클러스터링 적용
   - 인덱스의 조정
   - 응용애플리케이션
3. 반정규화 적용
   - 테이블 반정규화
   - 속성의 반정규화
   - 관계의 반정규화

##### 반정규화의 대상에 대해 다른 방법으로 처리

- 지나치게 많은 조인(JOIN)이 걸려 데이터를 조회하는 작업이 기술적으로 어려울 경우 뷰(VIEW)를 사용하면 이를 해결할 수도 있다.
- 대량의 데이터처리나 부분처리에 의해 성능이 저하되는 경우에 클러스터링을 적용하거나 인덱스를 조정함으로써 성능을 향상시킬 수 있다.
- 대랴의 데이터는 Primary Key의 성격에 따라 부분적인 테이블로 분리할 수 있다. 즉 파티셔닝 기법이 적용되어 성능저하를 방지할 수 있다.
- 응용 애플리케이션에서 로직을 구사하는 방법을 변경함으로써 성능을 향상시킬 수 있다.

##### 칼럼수가 많은 테이블에 대한 설명

- 한 테이블에 많은 칼럼들이 존재할 경우 데이터가 물리적으로 저장되는 디스크 상에 넓게 분포할 가능성이 커지게 되어 디스크 I/O가 대량으로 발생할 수 있고, 이로 인해 성능이 저하될 수 있음.
- 트랜잭션이 접근하는 칼럼유형을 분석해서 자주 접근하는 칼럼들과 상대적으로 접근 빈도가 낮은 칼럼들을 구분하여 1:1로 테이블을 분리하면 디스크 I/O가 줄어들어 성능을 향상 시킬 수 있다.

##### 파티셔닝(Partitionning)

: 하나의 테이블에 많은 양의 데이터가 저장되면 인덱스를 추가하고 테이블을 몇 개로 쪼개도 성능이 저하되는 경우가 있다. 이때 논리적으로는 하나의 테이블이지만 물리적으로 여러 개의 테이블로 분리하여 데이터 액세스 성능도 향상시키고, 데이터 관리방법도 개선할 수 있도록 테이블에 적용하는 기법

##### 논리데이터모델의 슈퍼타입과 서브타입 데이터 모델을 물리적인 테이블 형식으로 변환할 때

- 트랜잭션은 항상 전체를 대상으로 일괄 처리하는데 테이블은 서브타입별로 개별 유지하는 것으로 변환하면 Union 연산에 의해 성능이 저하될 수 있다.
- 트랜잭션은 항상 서브타입 개별로 처리하는데 테이블은 하나로 통합하여 변환하면 불필요하게 많은 양의 데이터가 집적되어 있어 성능이 저하될 수 있다.
- 트랜잭션은 항상 슈퍼+서브 타입을 함께 처리하는데 개별로 유지 하면 조인에 의해 성능이 저하될 수 있다.
- 트랜잭션은 항상 전체를 통합하여 분석처리하는데 슈퍼-서브타입이 하나의 테이블로 통합되어 있으면 하나의 테이블에 집적된 데이터만 읽어 처리할 수 있기 때문에 다른 형식에 비해 더 성능이 우수하다(조인감소)

SQL의 성능 설명

select건수, 금액

from실적

where일자 between '20110101' and '20110102'

​	and 지사코드 = '1001'

- '=' 로 들어온 조건에 해당하는 칼럼이 인덱스의 가장 앞쪽에 위치할 때 인덱스의 이용 효율성이 가장 높다.
  (Where 절에 첫 번째 조건으로 , 첫번째에 위치하는 것이 효율성이 높음)


##### 분산 데이터베이스 장단점

1. 장점
   - 지역 자치성, 점증적 시스템 용량 확장
   - 신뢰성과 가용성
   - 효용성과 융통성
   - 빠른 응답속도와 통신비용 절감
   - 데이터의 가용성과 신뢰성 증가
   - 시스템 규모의 적절한 조절
   - 각 지역 사용자의 요구 수용 증대
2. 단점
   - 소프트웨어 개발 비용
   - 오류의 잠재성 증대
   - 처리 비용의 증대
   - 설계, 관리의 복잡성과 비용
   - 불규칙한 응답 속도
   - 통제의 어려움
   - 데이터 무결성에 대한 위협

데이터가 여러 지역에 분산되어 있지만 하나의 데이터베이스 처럼 사용하기를 원하는 분산데이터베이스 환경에서 데이터베이스 분산 설계를 적용하여 효율성을 증대시킬 수 있는 것

- 공통코드, 기준정보 등 마스터 데이터는 분산데이터베이스에 복제분산을 적용
- DBMS가 제공하는 FK Constraints를 생성했는지 여부와 상관없이 조인성능을 향상시키기 위한 인덱스를 생성해주는 것이 좋다.
- Gloabal Single Instance(GSI)를 구성할 때 분산데이터베이스를 활용하여 구성하는 것이 효율적이다.



## SQL 기본 및 활용



##### SQL 문장들의 종류

<table>
    <thead>
    	<th>명령어의 종류</th>
        <th>명령어</th>
        <th>설명</th>
    </thead>
    <tbody>
        <tr>
            <td rowspan=3>데이터 조작어(DML : DataManipulation Language)</td>
        </tr>
        <tr>
            <td>SELECT</td>
            <td>데이터베이스에 들어 있는 데이터를 조회하거나 검색하기 위한 명령어를 말하는 것으로 RETRIEVE 라고도 한다.</td>
        </tr>
    	<tr>
        	<td>INSERT<br>UPDATE<br>DELETE</td>
        	<td>데이터베이스의 테이블에 들어 있는 데이터에 변형을 가하는 종류들의 명령어들을 말한다.예를 들어 데이터를 테이블에 새로운 행을 집어넣거나, 원하지 않는 데이터를 테이블에 새로운 행을 집어넣거나, 원하지 않는 데이터를 삭제하거나 수정하는 것들의 명령어들을 DML 이라고 부른다.</td>
    	</tr>
        <tr>
            <td>데이터 정의어(DDL: Data Definition Language)</td>
            <td>CREATE<br>ALTER<br>DROP<br>RENAME</td>
            <td>테이블과 같은 데이터 구조를 정의하는데 사용되는 명령어들로 그러한 구조를 생성하거나 변경하거나 삭제하거나 이름을 바꾸는 데이터 구조와 관련된 명령어들을 DDL이라고 부른다.</td>
        </tr>
		<tr>
            <td>데이터 제어어(DCL: Data Control Language)</td>
            <td>GRANT<br>REVOKE</td>
            <td>데이터베이스에 접근하고 객체들을 사용하도록 권한을 주고 회수하는 명령어를 DCL이라고 부른다.</td>
        </tr>
        <tr>
            <td>트랜잭션 제어어(TCL: Transaction Control Language)</td>
            <td>COMMIT<br>ROLLBACK</td>
            <td>논리적인 작업의 단위를 묶어서 DML에 의해 조작된 결과를 작업단위(트랜잭션)별로 제어하는 명령어를 말한다.</td>
        </tr>
	</tbody>
</table>

​    



##### 테이블 칼럼에 대한 정의 변경

- [Oracle]
  Alter table 테이블명 modify (칼럼명1 데이터 유형 [default 식], [not null], 칼럼명2 데이터 유형 ...);
- [SQL Server]
  Alter table 테이블명 alter (칼럼명1 데이터 유형 [default 식], [not null], 칼럼명2 데이터 유형...);

##### Null 설명

- 모르는 값을 의미한다.
- 값의 부재를 의미한다.
- 공백문자(Empty String) 혹은 숫자 0과 동일하지 않다.
- Null 과의 모든 비교(is null 제외) 는 알 수 없음(Unknown)을 반환한다.
- 아직 정의되지 않은 미지의 값
- 현재 데이터를 입려하지 못하는 경우



##### DDL 구문(DBMS는 Oracle 기준)

- DDL 올바른 문장

###### 1번 문장

create table PRODUCT( 

​	prod_id varchar2(10) not null

​	, prod_nm varchar2(100) not null)

​	, reg_dt date not null

​	, regr_no number(10) null

);

- DDL 잘못된 문장

###### 1번 문장

alter table PRODUCT add primary key product_pk on(prod_id); (X)

→ alter table PRODUCT add ***constraint*** product_pk primary key(prod_id); (O)

###### 2번 문장

create table PRODUCT( 

​	prod_id varchar2(10) not null

​	, prod_nm varchar2(100) not null)

​	, reg_dt date not null

​	, regr_no number(10) null

​	, ***add constraint primary key (prod_id***)

); (X)

→

create table PRODUCT( 

​	prod_id varchar2(10) not null

​	, prod_nm varchar2(100) not null)

​	, reg_dt date not null

​	, regr_no number(10) null

​	, ***constraint product_pk primary key(prod_id)***

); (O)



##### DDL 구문(DBMS는 SQLServer 기준)

기관분류

| 분류 ID : varchar(10) not null                               |
| ------------------------------------------------------------ |
| 분류명 : varchar(10) not null<br />등록일자 : varchar(10) null |

→ 

기관분류

| 분류 ID : varchar(10) not null                              |
| ----------------------------------------------------------- |
| 분류명 : varchar(30) not null<br />등록일자 : date not null |



- DDL 올바른 문장

alter table 기관분류 alter column 분류명 varchar(30) not null;



- DDL 잘못된 문장

###### 1번 문장

alter table 기관분류 alter column (분류명 varchar(30), 등록일자 date not null); (X)

alter table 기관분류 alter column (분류명 varchar(30) not null, 등록일자 date not null); (X)

→ SQLServer에서는 ***여러개의 컬럼을 동시******에 수정***하는 구문은 ***지원하지 않으므로*** 오류 발생. 또한 괄호를 사용하지 않는다.



###### 2번문장

alter table 기관분류 alter column 등록일자 date not null; (X)

→ 분류명을 수정할 때 not null 구문을 지정하지 않으면, 기존의 not null 제약조건이 null로 변경되므로 not null 요건을 만족하지 않는다.

###### 

EMP

| EMP_NO : varchar2(10) not null                               |
| ------------------------------------------------------------ |
| emp_nm : varchar2(30) not null<br />dept_code : varchar2(4) not null<br />join_date : date not null<br />regist_date : date null |

- DDL 올바른 문장

###### 1번 문장

create table EMP (

​	emp_no varchar2(10) primary key

​	, emp_nm varchar2(30) not null

​	, dept_code varchar2(4) default '0000' not null

​	, join_date date not null

​	, regist_date date null

); 

###### 2번 문장

create table EMP (

​	emp_no varchar2(10) not null

​	, emp_nm varchar2(30) not null

​	, dept_code varchar2(4) default '0000' not null

​	, join_date date not null

​	, regist_date date

);

alter table EMP add constraint emp_pk_primary key(emp_no);

create index idx_emp_01 on EMP (join_date);



- DDL 잘못된 문장

###### 1번 문장

create table EMP (

​	emp_no varchar2(10) primary key

​	, emp_nm varchar2(30) not null

​	, ***dept_code varchar2(4) default '0000'***

​	, join_date date not null

​	, regist_date date

);

→ SQL은 정상적으로 수행되지만, dept_code 칼럼에 not null 제약조건이 생성되지 않는다.

해당 칼럼에 null 을 입력하게 되면 문제가 발생한다.



###### 2번문장

create table EMP (

​	emp_no varchar2(10) not null ***primary key***

​	, emp_nm varchar2(30) not null

​	, dept_code varchar2(4) default '0000' not null

​	, join_date date not null

​	, join_date not null

);

***alter table EMP add constraint emp_pk_primary key (emp_no);***

create index idx_emp_01 on EMP (join_date);

→ 테이블 생성문과 인덱스 생성문은 정상적으로 수행되지만, 테이블 생성문장에서 이미 primary key를 지정하였으므로 alter table 문장에서 오류가 발생한다.



##### 테이블 생성시 칼럼별 생성할 수 있는 제약 조건(Constraints) 설명

- UNIQUE : 테이블 내에는 중복되는 값이 없으며 NOT NULL 특징을 갖는다.
- PK : 주키로 테이블당 1개만 생성이 가능하다.
- FK : 외래키로 테이블당 여러 개 생성이 가능하다.
- NOT NULL : 명시적으로 NULL 입력을 방지한다.

##### 테이블 생성의 주의사항

- 테이블명은 객체를 의미할 수 있는 적절한 이름을 사용한다. 가능한 단수형을 권고한다.
- 테이블 명은 다른 테이블 의 이름과 중복되지 않아야 한다.
- 한 테이블 내에서는 칼럼명이 중복되게 지정될 수 없다.
- 테이블 이름을 지정하고 각 칼럼들은 괄호 "( )"로 묶어 지정한다.
- 각 칼럼들은 콤마 "."로 구분되고, 테이블 생성문의 끝은 항상 세미콜론";"으로 끝난다.
- 칼럼에 대해서는 다른 테이블까지 고려하여 데이터베이스 내에서는 일관성 있게 사용하는 것이 좋다.(데이터 표준화 관점)
- 칼럼 뒤에 데이터 유형은 꼭 지정되어야 한다.
- 테이블명과 칼럼명은 반드시 문자로 시작해야 하고, 벤더별로 길이에 대한 한계가 있다.
- 벤더에서 사전에 정의한 예약어(Reserved word)는 쓸 수 없다.
- A-Z, a-z, 0-9, _, $, # 문자만 허용된다.

